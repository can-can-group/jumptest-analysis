<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CMJ Force Plate — Phase & Key Point Viewer</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js" defer></script>
  <script defer>
    if (typeof ChartAnnotation !== 'undefined') Chart.register(ChartAnnotation);
  </script>
  <style>
    :root {
      --bg: #f5f5f5;
      --surface: #ffffff;
      --text: #333333;
      --muted: #666666;
      --border: #e0e0e0;
      --orange: #FF8C00;
      --orange-muted: #FFA07A;
      --grey-dark: #333333;
      --grey-mid: #999999;
    }
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }
    .container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 1.5rem;
    }
    h1 {
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: var(--grey-dark);
    }
    .subtitle { color: var(--muted); font-size: 0.9rem; margin-bottom: 1.5rem; }
    .toolbar {
      display: flex;
      gap: 1rem;
      align-items: center;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }
    .toolbar label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      color: var(--text);
    }
    .toolbar label:hover { border-color: var(--grey-mid); }
    .toolbar input[type="file"] { display: none; }
    .meta {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem 1.25rem;
      margin-bottom: 1.5rem;
      font-size: 0.85rem;
    }
    .meta-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 0.75rem;
    }
    .meta-item { color: var(--muted); }
    .meta-item strong { color: var(--text); }
    .validity-invalid { color: #c53030; }
    .validity-ok { color: #276749; }
    .chart-wrap {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 1.25rem;
      margin-bottom: 1.5rem;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    }
    .chart-wrap canvas { max-width: 100%; }
    .sections { display: flex; flex-direction: column; gap: 1.5rem; }
    .phases-keypoints-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
    }
    @media (max-width: 700px) { .phases-keypoints-row { grid-template-columns: 1fr; } }
    .metrics-section { width: 100%; }
    .panel {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1.25rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    }
    .panel h2 {
      font-size: 1rem;
      font-weight: 600;
      margin: 0 0 1rem 0;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border);
      color: var(--grey-dark);
    }
    .phase-list, .keypoint-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .phase-list li, .keypoint-list li {
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--border);
      font-size: 0.9rem;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 0.15rem;
    }
    .phase-list li > .row, .keypoint-list li > .row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 1rem;
    }
    .item-desc {
      font-size: 0.75rem;
      color: var(--muted);
      line-height: 1.25;
      margin-top: 0.1rem;
    }
    .phase-list li:last-child, .keypoint-list li:last-child { border-bottom: none; }
    .metrics-section .metrics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 0.5rem 1.5rem;
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .metrics-section .metrics-grid li {
      padding: 0.4rem 0;
      border-bottom: 1px solid var(--border);
      font-size: 0.85rem;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.75rem;
    }
    .metrics-section .metrics-grid li:last-child { border-bottom: none; }
    .metrics-section .metric-key { font-weight: 500; color: var(--text); }
    .metrics-section .metric-value { color: var(--muted); font-size: 0.85em; }
    .phase-list li[title], .keypoint-list li[title], .metrics-section .metrics-grid li[title] { cursor: help; }
    .phase-dot {
      width: 10px;
      height: 10px;
      border-radius: 2px;
      flex-shrink: 0;
      margin-right: 0.5rem;
    }
    .phase-name { font-weight: 500; color: var(--text); }
    .phase-time, .kp-value { color: var(--muted); font-size: 0.85em; }
    .empty { color: var(--muted); text-align: center; padding: 2rem; }
    .comparison-container { display: none; margin-top: 1.5rem; }
    .comparison-container.visible { display: block; }
    .comparison-row { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; }
    @media (max-width: 900px) { .comparison-row { grid-template-columns: 1fr; } }
    .trial-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .trial-card h3 { font-size: 0.95rem; margin: 0 0 0.5rem 0; color: var(--grey-dark); }
    .trial-meta-compact { font-size: 0.8rem; color: var(--muted); margin-bottom: 0.5rem; }
    .trial-card .panel { padding: 0.75rem; }
    .trial-card .panel h2 { font-size: 0.9rem; margin: 0 0 0.5rem 0; padding-bottom: 0.35rem; }
    .trial-card .phase-list li, .trial-card .keypoint-list li { padding: 0.35rem 0; font-size: 0.85rem; }
    .trial-card .metrics-grid { font-size: 0.8rem; }
    .comparison-section-title { font-size: 1.1rem; font-weight: 600; margin-bottom: 1rem; color: var(--grey-dark); }
    .delta-gain { color: #16a34a; font-weight: 500; }
    .delta-loss { color: #dc2626; font-weight: 500; }
    .delta-neutral { color: var(--muted); }
    .comparison-table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
    .comparison-table th, .comparison-table td { padding: 0.4rem 0.6rem; text-align: left; border-bottom: 1px solid var(--border); }
    .comparison-table th { font-weight: 600; color: var(--grey-dark); }
    .comparison-table .col-t1 { color: var(--muted); }
    .comparison-table .col-t2 { color: var(--text); }
    .comparison-table .col-delta { min-width: 6rem; }
    .chart-wrap-trial2 { margin-top: 1rem; }
    .compare-modal-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.4);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    .compare-modal-overlay.visible { display: flex; }
    .compare-modal {
      background: var(--surface);
      border-radius: 12px;
      padding: 1.5rem;
      max-width: 420px;
      width: 90%;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    }
    .compare-modal h3 { margin: 0 0 1rem 0; font-size: 1.1rem; color: var(--grey-dark); }
    .compare-modal-list {
      list-style: none;
      padding: 0;
      margin: 0 0 1rem 0;
      overflow-y: auto;
      flex: 1;
    }
    .compare-modal-list li {
      padding: 0.6rem 0.75rem;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      font-size: 0.9rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .compare-modal-list li:hover { background: var(--bg); }
    .compare-modal-list li .duration { color: var(--muted); font-size: 0.85em; }
    .compare-modal-actions { display: flex; justify-content: flex-end; gap: 0.5rem; margin-top: 0.5rem; }
    .compare-modal-actions button {
      padding: 0.5rem 1rem;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--surface);
      cursor: pointer;
      font-size: 0.9rem;
    }
    .compare-modal-actions button.primary { background: var(--grey-dark); color: #fff; border-color: var(--grey-dark); }
    .toolbar .compare-btn { padding: 0.5rem 1rem; border-radius: 8px; border: 1px solid var(--border); background: var(--surface); cursor: pointer; font-size: 0.9rem; color: var(--text); }
    .toolbar .compare-btn:hover { border-color: var(--grey-mid); }
  </style>
</head>
<body>
  <div class="container">
    <h1>CMJ Force Plate — Phase & Key Point Viewer</h1>
    <p class="subtitle" id="subtitle">Jump test results from the API.</p>

    <div id="compareToolbar" class="toolbar" style="display: none; margin-bottom: 1rem;">
      <button type="button" class="compare-btn" id="compareBtn">Compare with another test…</button>
    </div>

    <div id="compareModalOverlay" class="compare-modal-overlay" aria-hidden="true">
      <div class="compare-modal">
        <h3>Select a test to compare</h3>
        <ul id="compareModalList" class="compare-modal-list"></ul>
        <div class="compare-modal-actions">
          <button type="button" id="compareModalClose">Cancel</button>
        </div>
      </div>
    </div>

    <div id="meta" class="meta" style="display: none;">
      <div class="meta-grid" id="metaGrid"></div>
      <div id="validityMsg" style="margin-top: 0.75rem;"></div>
    </div>

    <div id="chartWrap" class="chart-wrap" style="display: none;">
      <canvas id="chart"></canvas>
    </div>

    <div id="sections" class="sections analysis-block" style="display: none;">
      <div class="phases-keypoints-row">
        <div class="panel">
          <h2>Phases</h2>
          <ul id="phaseList" class="phase-list"></ul>
        </div>
        <div class="panel">
          <h2>Key points</h2>
          <ul id="keypointList" class="keypoint-list"></ul>
        </div>
      </div>
      <div class="metrics-section panel">
        <h2>Metrics</h2>
        <ul id="metricsList" class="metrics-grid"></ul>
      </div>
    </div>

    <div id="comparisonContainer" class="comparison-container">
      <div class="comparison-section-title">Trial 2 — Chart</div>
      <div id="chartWrap2" class="chart-wrap chart-wrap-trial2" style="display: none;">
        <canvas id="chart2"></canvas>
      </div>
      <div class="comparison-section-title" style="margin-top: 1.5rem;">Phases, key points & metrics — Trial 1 vs Trial 2</div>
      <div id="comparisonTables" class="panel" style="margin-top: 0.5rem;"></div>
    </div>

    <p id="placeholder" class="empty">Loading…</p>
  </div>
  <!-- INJECT_VIZ_DATA -->
  <!-- INJECT_ATHLETE_DETAILS -->
  <script>
    // Reference style: light fills, grey/orange; stronger contrast so phases are visible
    const PHASE_COLORS = {
      'Quiet': 'rgba(51, 51, 51, 0.08)',
      'Eccentric': 'rgba(255, 140, 0, 0.14)',
      'Eccentric - Unloading': 'rgba(255, 140, 0, 0.14)',
      'Eccentric - Braking': 'rgba(255, 140, 0, 0.22)',
      'Concentric': 'rgba(180, 180, 180, 0.5)',
      'Flight': 'rgba(0, 0, 0, 0.06)',
      'Landing': 'rgba(255, 160, 122, 0.22)'
    };
    function phaseLabelShort(name) {
      if (name === 'Eccentric - Unloading') return 'Eccentric';
      if (name === 'Eccentric - Braking') return 'Braking';
      return name;
    }
    const PHASE_LINE_COLORS = {
      'Quiet': '#333333',
      'Eccentric - Unloading': '#FF8C00',
      'Eccentric - Braking': '#FF8C00',
      'Concentric': '#333333',
      'Flight': '#000000',
      'Landing': '#FFA07A'
    };
    function getPhaseAtTime(phases, t) {
      for (let i = phases.length - 1; i >= 0; i--) {
        if (t >= phases[i].start_time_s && t <= phases[i].end_time_s) return phases[i].name;
      }
      return 'Quiet';
    }
    function getLineColorForPhase(phaseName) {
      return PHASE_LINE_COLORS[phaseName] || '#333333';
    }
    function keyPointLineColor(name) {
      const orange = '#FF8C00';
      const grey = '#999999';
      if (/Start of movement|Minimum force|Max RFD/i.test(name)) return orange;
      return grey;
    }

    let chartInstance = null;
    let chartInstance2 = null;

    function formatTime(s) {
      if (s == null) return '—';
      return Number(s).toFixed(3) + ' s';
    }
    function formatDuration(s) {
      if (s == null) return '—';
      const n = Number(s);
      if (n < 0) return '—';
      return n.toFixed(3) + ' s';
    }

    function formatVal(v) {
      if (v == null) return '—';
      const n = Number(v);
      return n.toFixed(2);
    }

    function renderMeta(data) {
      const g = document.getElementById('metaGrid');
      const ad = (typeof window !== 'undefined' && window.ATHLETE_DETAILS) ? window.ATHLETE_DETAILS : null;
      const firstName = ad && ad.first_name != null ? ad.first_name : (ad ? '—' : (data.athlete_id || '—'));
      const lastName = ad && ad.last_name != null ? ad.last_name : '—';
      const gender = ad && ad.gender != null ? ad.gender : '—';
      const age = ad && ad.age != null ? String(ad.age) : '—';
      g.innerHTML = `
        <span class="meta-item">Name <strong>${escapeHtml(firstName)}</strong></span>
        <span class="meta-item">Last name <strong>${escapeHtml(lastName)}</strong></span>
        <span class="meta-item">Gender <strong>${escapeHtml(gender)}</strong></span>
        <span class="meta-item">Age <strong>${age}</strong></span>
        <span class="meta-item">Test <strong>${data.test_type || '—'}</strong></span>
        <span class="meta-item">Bodyweight <strong>${formatVal(data.bodyweight_N)} N</strong></span>
        <span class="meta-item">Sample rate <strong>${formatVal(data.sample_rate)} Hz</strong></span>
      `;
      const vDiv = document.getElementById('validityMsg');
      if (data.validity && !data.validity.is_valid && data.validity.flags && data.validity.flags.length) {
        vDiv.className = 'validity-invalid';
        vDiv.textContent = 'Flags: ' + data.validity.flags.join(', ');
      } else {
        vDiv.className = 'validity-ok';
        vDiv.textContent = 'Trial valid.';
      }
      document.getElementById('meta').style.display = 'block';
    }

    function renderPhaseList(phases) {
      const ul = document.getElementById('phaseList');
      if (!phases || phases.length === 0) {
        ul.innerHTML = '<li class="empty">No phases</li>';
        return;
      }
      ul.innerHTML = phases.map((p, i) => {
        const color = getLineColorForPhase(p.name);
        const title = p.explanation ? ` title="${escapeAttr(p.explanation)}"` : '';
        const desc = p.explanation ? `<span class="item-desc">${escapeHtml(p.explanation)}</span>` : '';
        const durationS = p.duration_s != null ? p.duration_s : (p.end_time_s != null && p.start_time_s != null ? p.end_time_s - p.start_time_s : null);
        const durationStr = durationS != null ? ` · ${formatDuration(durationS)}` : '';
        return `
          <li${title}>
            <div class="row">
              <span style="display:flex;align-items:center;">
                <span class="phase-dot" style="background:${color}"></span>
                <span class="phase-name">${p.name}</span>
              </span>
              <span class="phase-time">${formatTime(p.start_time_s)} → ${formatTime(p.end_time_s)}${durationStr}</span>
            </div>
            ${desc}
          </li>
        `;
      }).join('');
    }

    function renderKeypointList(keyPoints) {
      const ul = document.getElementById('keypointList');
      if (!keyPoints || keyPoints.length === 0) {
        ul.innerHTML = '<li class="empty">No key points</li>';
        return;
      }
      ul.innerHTML = keyPoints.map((kp, i) => {
        const timeStr = formatTime(kp.time_s);
        const val = kp.value_N != null ? formatVal(kp.value_N) + ' N' : (kp.value_N_per_s != null ? formatVal(kp.value_N_per_s) + ' N/s' : '');
        const title = kp.explanation ? ` title="${escapeAttr(kp.explanation)}"` : '';
        const desc = kp.explanation ? `<span class="item-desc">${escapeHtml(kp.explanation)}</span>` : '';
        const valueStr = val ? ` at ${timeStr} · ${val}` : ` at ${timeStr}`;
        return `
          <li${title}>
            <div class="row">
              <span class="phase-name">${kp.name}</span>
              <span class="kp-value">${valueStr}</span>
            </div>
            ${desc}
          </li>
        `;
      }).join('');
    }

    function escapeAttr(s) {
      if (s == null) return '';
      return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
    function escapeHtml(s) {
      if (s == null) return '';
      return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function metricLabel(key) {
      return key.replace(/_/g, ' ');
    }

    function getPhasesForDisplay(data) {
      if (data.analysis && data.analysis.phases && data.analysis.phase_order) {
        return data.analysis.phase_order
          .map(slug => data.analysis.phases[slug])
          .filter(Boolean)
          .map(p => ({ ...p.value, explanation: p.explanation }));
      }
      return data.phases || [];
    }

    function getKeyPointsForDisplay(data) {
      if (data.analysis && data.analysis.key_points && data.analysis.key_point_order) {
        return data.analysis.key_point_order
          .map(slug => data.analysis.key_points[slug])
          .filter(Boolean)
          .map(k => ({ ...k.value, explanation: k.explanation }));
      }
      return data.key_points || [];
    }

    function getMetricsForDisplay(data) {
      return (data.analysis && data.analysis.metrics) ? data.analysis.metrics : null;
    }

    function buildTrialCardHtml(data, label) {
      const phases = getPhasesForDisplay(data);
      const keyPoints = getKeyPointsForDisplay(data);
      const metricsObj = getMetricsForDisplay(data);
      const meta = [
        data.athlete_id ? `Athlete: ${data.athlete_id}` : '',
        data.bodyweight_N != null ? `BW: ${formatVal(data.bodyweight_N)} N` : ''
      ].filter(Boolean).join(' · ');
      let phasesHtml = '';
      if (phases.length === 0) {
        phasesHtml = '<ul class="phase-list"><li class="empty">No phases</li></ul>';
      } else {
        phasesHtml = '<ul class="phase-list">' + phases.map((p) => {
          const color = getLineColorForPhase(p.name);
          const durationS = p.duration_s != null ? p.duration_s : (p.end_time_s != null && p.start_time_s != null ? p.end_time_s - p.start_time_s : null);
          const durationStr = durationS != null ? ` · ${formatDuration(durationS)}` : '';
          return `<li><div class="row"><span style="display:flex;align-items:center;"><span class="phase-dot" style="background:${color}"></span><span class="phase-name">${p.name}</span></span><span class="phase-time">${formatTime(p.start_time_s)} → ${formatTime(p.end_time_s)}${durationStr}</span></div></li>`;
        }).join('') + '</ul>';
      }
      let kpHtml = '';
      if (!keyPoints || keyPoints.length === 0) {
        kpHtml = '<ul class="keypoint-list"><li class="empty">No key points</li></ul>';
      } else {
        kpHtml = '<ul class="keypoint-list">' + keyPoints.map((kp) => {
          const timeStr = formatTime(kp.time_s);
          const val = kp.value_N != null ? formatVal(kp.value_N) + ' N' : (kp.value_N_per_s != null ? formatVal(kp.value_N_per_s) + ' N/s' : '');
          const valueStr = val ? ` at ${timeStr} · ${val}` : ` at ${timeStr}`;
          return `<li><div class="row"><span class="phase-name">${kp.name}</span><span class="kp-value">${valueStr}</span></div></li>`;
        }).join('') + '</ul>';
      }
      let metricsHtml = '';
      if (!metricsObj || typeof metricsObj !== 'object') {
        metricsHtml = '<ul class="metrics-grid"><li class="empty">No metrics</li></ul>';
      } else {
        const entries = Object.entries(metricsObj).sort((a, b) => a[0].localeCompare(b[0]));
        metricsHtml = '<ul class="metrics-grid">' + entries.map(([key, item]) => {
          const value = item && typeof item === 'object' && 'value' in item ? item.value : item;
          const displayVal = value == null ? '—' : (typeof value === 'number' ? (Number.isInteger(value) ? value : formatVal(value)) : String(value));
          return `<li><span class="metric-key">${metricLabel(key)}</span><span class="metric-value">${displayVal}</span></li>`;
        }).join('') + '</ul>';
      }
      return `
        <h3>${escapeHtml(label)}</h3>
        <div class="trial-meta-compact">${escapeHtml(meta)}</div>
        <div class="panel"><h2>Phases</h2>${phasesHtml}</div>
        <div class="panel"><h2>Key points</h2>${kpHtml}</div>
        <div class="panel"><h2>Metrics</h2>${metricsHtml}</div>
      `;
    }

    function deltaClass(delta) {
      if (delta == null || delta === 0) return 'delta-neutral';
      return delta > 0 ? 'delta-gain' : 'delta-loss';
    }

    function formatDelta(delta, unit) {
      if (delta == null || typeof delta !== 'number') return '—';
      const sign = delta >= 0 ? '+' : '';
      const u = unit ? ' ' + unit : '';
      return sign + (Number.isInteger(delta) ? delta : delta.toFixed(3)) + u;
    }

    function buildComparisonTables(dataA, dataB) {
      const phasesA = getPhasesForDisplay(dataA);
      const phasesB = getPhasesForDisplay(dataB);
      const kpA = getKeyPointsForDisplay(dataA);
      const kpB = getKeyPointsForDisplay(dataB);
      const metricsA = getMetricsForDisplay(dataA);
      const metricsB = getMetricsForDisplay(dataB);

      const phaseNames = [...new Set([...phasesA.map(p => p.name), ...phasesB.map(p => p.name)])];
      const getDuration = (p) => p.duration_s != null ? p.duration_s : (p.end_time_s != null && p.start_time_s != null ? p.end_time_s - p.start_time_s : null);
      let phasesRows = phaseNames.map(name => {
        const pA = phasesA.find(p => p.name === name);
        const pB = phasesB.find(p => p.name === name);
        const d1 = pA ? getDuration(pA) : null;
        const d2 = pB ? getDuration(pB) : null;
        const delta = (d1 != null && d2 != null) ? d2 - d1 : null;
        const cls = deltaClass(delta);
        return `<tr><td>${escapeHtml(name)}</td><td class="col-t1">${d1 != null ? formatDuration(d1) : '—'}</td><td class="col-t2">${d2 != null ? formatDuration(d2) : '—'}</td><td class="col-delta ${cls}">${delta != null ? formatDelta(delta, 's') : '—'}</td></tr>`;
      }).join('');

      const kpNames = [...new Set([...(kpA || []).map(k => k.name), ...(kpB || []).map(k => k.name)])];
      const kpRows = kpNames.map(name => {
        const a = (kpA || []).find(k => k.name === name);
        const b = (kpB || []).find(k => k.name === name);
        const t1 = a ? (a.time_s != null ? formatTime(a.time_s) : '—') + (a.value_N != null ? ' · ' + formatVal(a.value_N) + ' N' : '') : '—';
        const t2 = b ? (b.time_s != null ? formatTime(b.time_s) : '—') + (b.value_N != null ? ' · ' + formatVal(b.value_N) + ' N' : '') : '—';
        let deltaHtml = '—';
        if (a && b && a.time_s != null && b.time_s != null) {
          const dt = b.time_s - a.time_s;
          const dv = (a.value_N != null && b.value_N != null) ? b.value_N - a.value_N : null;
          const parts = [formatDelta(dt, 's')];
          if (dv != null) parts.push(formatDelta(dv, 'N'));
          deltaHtml = `<span class="${deltaClass(dt)}">${parts[0]}</span>${dv != null ? ` <span class="${deltaClass(dv)}">${formatDelta(dv, 'N')}</span>` : ''}`;
        }
        return `<tr><td>${escapeHtml(name)}</td><td class="col-t1">${t1}</td><td class="col-t2">${t2}</td><td class="col-delta">${deltaHtml}</td></tr>`;
      }).join('');

      const allMetricKeys = [...new Set([...Object.keys(metricsA || {}), ...Object.keys(metricsB || {})])].sort((a, b) => a.localeCompare(b));
      const getMetricVal = (obj, k) => {
        if (!obj || !obj[k]) return null;
        const v = obj[k];
        return (v && typeof v === 'object' && 'value' in v) ? v.value : v;
      };
      const metricRows = allMetricKeys.map(key => {
        const v1 = getMetricVal(metricsA, key);
        const v2 = getMetricVal(metricsB, key);
        const num1 = typeof v1 === 'number' ? v1 : null;
        const num2 = typeof v2 === 'number' ? v2 : null;
        const delta = (num1 != null && num2 != null) ? num2 - num1 : null;
        const cls = deltaClass(delta);
        const disp1 = v1 == null ? '—' : (typeof v1 === 'number' ? (Number.isInteger(v1) ? v1 : formatVal(v1)) : String(v1));
        const disp2 = v2 == null ? '—' : (typeof v2 === 'number' ? (Number.isInteger(v2) ? v2 : formatVal(v2)) : String(v2));
        return `<tr><td>${escapeHtml(metricLabel(key))}</td><td class="col-t1">${disp1}</td><td class="col-t2">${disp2}</td><td class="col-delta ${cls}">${delta != null ? formatDelta(delta, '') : '—'}</td></tr>`;
      }).join('');

      return `
        <h3 style="font-size:0.95rem;margin:0 0 0.5rem 0;">Phases (duration)</h3>
        <table class="comparison-table"><thead><tr><th>Phase</th><th>Trial 1</th><th>Trial 2</th><th>Change</th></tr></thead><tbody>${phasesRows}</tbody></table>
        <h3 style="font-size:0.95rem;margin:1rem 0 0.5rem 0;">Key points</h3>
        <table class="comparison-table"><thead><tr><th>Point</th><th>Trial 1</th><th>Trial 2</th><th>Change</th></tr></thead><tbody>${kpRows}</tbody></table>
        <h3 style="font-size:0.95rem;margin:1rem 0 0.5rem 0;">Metrics</h3>
        <table class="comparison-table"><thead><tr><th>Metric</th><th>Trial 1</th><th>Trial 2</th><th>Change</th></tr></thead><tbody>${metricRows}</tbody></table>
      `;
    }

    function renderComparison(dataA, dataB) {
      if (!dataA || !dataB) {
        document.getElementById('comparisonContainer').classList.remove('visible');
        document.getElementById('chartWrap2').style.display = 'none';
        if (chartInstance2) { chartInstance2.destroy(); chartInstance2 = null; }
        return;
      }
      document.getElementById('chartWrap2').style.display = 'block';
      buildChart(dataB, 'chart2');
      document.getElementById('comparisonTables').innerHTML = buildComparisonTables(dataA, dataB);
      document.getElementById('comparisonContainer').classList.add('visible');
    }

    function renderMetricsList(metricsObj) {
      const ul = document.getElementById('metricsList');
      if (!metricsObj || typeof metricsObj !== 'object') {
        ul.innerHTML = '<li class="empty">No metrics</li>';
        return;
      }
      const entries = Object.entries(metricsObj).sort((a, b) => a[0].localeCompare(b[0]));
      if (entries.length === 0) {
        ul.innerHTML = '<li class="empty">No metrics</li>';
        return;
      }
      ul.innerHTML = entries.map(([key, item]) => {
        const value = item && typeof item === 'object' && 'value' in item ? item.value : item;
        const explanation = item && typeof item === 'object' && 'explanation' in item ? item.explanation : '';
        const title = explanation ? ` title="${escapeAttr(explanation)}"` : '';
        const displayVal = value == null ? '—' : (typeof value === 'number' ? (Number.isInteger(value) ? value : formatVal(value)) : String(value));
        return `
          <li${title}>
            <span class="metric-key">${metricLabel(key)}</span>
            <span class="metric-value">${displayVal}</span>
          </li>
        `;
      }).join('');
    }

    function buildFillUnderCurve(time, force, startTime, endTime, fillColor) {
      const pts = [];
      let i0 = 0;
      while (i0 < time.length && time[i0] < startTime) i0++;
      let i1 = time.length - 1;
      while (i1 >= 0 && time[i1] > endTime) i1--;
      if (i0 > i1) return pts;
      pts.push({ x: time[i0], y: 0 });
      for (let i = i0; i <= i1; i++) pts.push({ x: time[i], y: force[i] });
      pts.push({ x: time[i1], y: 0 });
      return pts;
    }

    function buildChart(data, targetChartId) {
      if (typeof Chart === 'undefined') {
        var el = document.getElementById('placeholder');
        if (el) { el.textContent = 'Chart library failed to load. Check your connection and try again.'; el.style.color = '#c53030'; el.style.display = 'block'; }
        return;
      }
      const canvasId = targetChartId || 'chart';
      const canvasEl = document.getElementById(canvasId);
      if (!canvasEl) return;
      if (!data || !Array.isArray(data.time_s) || !Array.isArray(data.force_N) || data.time_s.length === 0) return;
      data.key_points = data.key_points || [];
      data.phases = data.phases || [];
      if (canvasId === 'chart2' && chartInstance2) { chartInstance2.destroy(); chartInstance2 = null; }
      else if (!targetChartId && chartInstance) { chartInstance.destroy(); chartInstance = null; }

      const time = data.time_s;
      const force = data.force_N;
      const leftForce = data.left_force_N || data.force_N;
      const rightForce = data.right_force_N || data.force_N;
      const bodyweight = data.bodyweight_N;
      const phases = data.phases || [];

      // Use (x, y) points so the x-axis is linear time – annotations use the same scale
      const totalPoints = time.map((t, i) => ({ x: t, y: force[i] }));
      const leftPoints = time.map((t, i) => ({ x: t, y: leftForce[i] }));
      const rightPoints = time.map((t, i) => ({ x: t, y: rightForce[i] }));

      // Fill-under-curve for Eccentric (Unloading + Braking) and Concentric
      const unloadingPhaseForFill = phases.find(p => p.name === 'Eccentric - Unloading');
      const brakingPhaseForFill = phases.find(p => p.name === 'Eccentric - Braking');
      const eccentricStart = unloadingPhaseForFill ? unloadingPhaseForFill.start_time_s : (phases.find(p => /Eccentric/i.test(p.name))?.start_time_s);
      const eccentricEnd = brakingPhaseForFill ? brakingPhaseForFill.end_time_s : (phases.find(p => /Eccentric/i.test(p.name))?.end_time_s);
      const eccentricFillPoints = (eccentricStart != null && eccentricEnd != null)
        ? buildFillUnderCurve(time, force, eccentricStart, eccentricEnd, 'rgba(255, 140, 0, 0.25)')
        : [];
      const concentricPhase = phases.find(p => /Concentric/i.test(p.name));
      const concentricFillPoints = concentricPhase
        ? buildFillUnderCurve(time, force, concentricPhase.start_time_s, concentricPhase.end_time_s, 'rgba(224, 224, 224, 0.85)')
        : [];

      // Key point markers on the curve: (x, y) and color per point
      const keyPointData = data.key_points.map(kp => ({
        x: kp.time_s,
        y: kp.value_N != null ? kp.value_N : (force[kp.index] ?? 0)
      }));
      const keyPointColors = data.key_points.map(kp =>
        /Start of movement|Minimum force|Max RFD/i.test(kp.name) ? '#FF8C00' : '#333333'
      );

      const annotations = {};
      const yMaxForce = Math.max(...force);

      // Main phases: merge Eccentric sub-phases into one "Eccentric" bracket; sub-phases drawn below
      const unloadingPhase = phases.find(p => p.name === 'Eccentric - Unloading');
      const brakingPhase = phases.find(p => p.name === 'Eccentric - Braking');
      const mainPhases = [];
      for (const p of phases) {
        if (p.name === 'Eccentric - Unloading' || p.name === 'Eccentric - Braking') {
          if (mainPhases.every(m => m.name !== 'Eccentric')) {
            const start = unloadingPhase ? unloadingPhase.start_time_s : p.start_time_s;
            const end = brakingPhase ? brakingPhase.end_time_s : p.end_time_s;
            mainPhases.push({ name: 'Eccentric', start_time_s: start, end_time_s: end });
          }
          continue;
        }
        mainPhases.push({ name: p.name, start_time_s: p.start_time_s, end_time_s: p.end_time_s });
      }

      // Main phase boxes: full height, label at top
      mainPhases.forEach((p, i) => {
        const color = PHASE_COLORS[p.name] || (p.name === 'Eccentric' ? 'rgba(255, 140, 0, 0.14)' : 'rgba(128,128,128,0.08)');
        annotations[`box_main_${i}`] = {
          type: 'box',
          xMin: p.start_time_s,
          xMax: p.end_time_s,
          yMin: 'min',
          yMax: 'max',
          backgroundColor: color,
          borderWidth: 0,
          label: {
            display: true,
            content: p.name,
            position: 'start',
            color: '#666666',
            font: { size: 11 }
          }
        };
      });

      // Sub-phases (Unloading, Braking): dotted line and labels — place below P1/P2 when they are high to avoid overlap
      const keyPointYs = (data.key_points || []).map(kp => kp.value_N != null ? kp.value_N : (force[kp.index] ?? 0));
      const highKeyPointYs = keyPointYs.filter(y => y > yMaxForce * 0.5);
      const minHighKeyY = highKeyPointYs.length > 0 ? Math.min(...highKeyPointYs) : null;
      const defaultSubY = yMaxForce * 0.92;
      const subPhaseLineY = minHighKeyY != null
        ? Math.max(yMaxForce * 0.5, Math.min(defaultSubY, minHighKeyY * 0.78))
        : defaultSubY;
      [unloadingPhase, brakingPhase].filter(Boolean).forEach((p, i) => {
        const subLabel = p.name === 'Eccentric - Unloading' ? 'Unloading' : 'Braking';
        annotations[`line_sub_${i}`] = {
          type: 'line',
          xMin: p.start_time_s,
          xMax: p.end_time_s,
          yMin: subPhaseLineY,
          yMax: subPhaseLineY,
          borderColor: 'rgba(255, 140, 0, 0.7)',
          borderWidth: 1.5,
          borderDash: [4, 3],
          label: {
            display: true,
            content: subLabel,
            position: i === 0 ? 'start' : 'end',
            xAdjust: i === 0 ? 8 : -8,
            yAdjust: -10,
            backgroundColor: 'transparent',
            borderWidth: 0,
            color: '#666666',
            font: { size: 10 }
          }
        };
      });

      // Vertical separator between Unloading and Braking (at min-force boundary) so the two sub-phases are clearly distinct
      if (unloadingPhase && brakingPhase) {
        const boundaryTime = unloadingPhase.end_time_s;
        const sepHeight = yMaxForce * 0.06;
        annotations.subphase_separator = {
          type: 'line',
          xMin: boundaryTime,
          xMax: boundaryTime,
          yMin: subPhaseLineY - sepHeight,
          yMax: subPhaseLineY + sepHeight * 0.5,
          borderColor: 'rgba(255, 140, 0, 0.8)',
          borderWidth: 1.5,
          borderDash: [3, 3]
        };
      }

      // Key point labels: always visible on chart, no vertical lines; staggered so they don't overlap
      function keyPointLabelText(name) {
        if (/Start of movement/i.test(name)) return 'Start of movement';
        if (/Minimum force/i.test(name)) return 'Min force';
        if (/P1 peak/i.test(name)) return 'P1';
        if (/P2 peak/i.test(name)) return 'P2';
        return name;
      }
      data.key_points.forEach((kp, i) => {
        const yVal = kp.value_N != null ? kp.value_N : (force[kp.index] ?? 0);
        const isOrange = /Start of movement|Minimum force/i.test(kp.name);
        const row = i % 3;
        const col = Math.floor(i / 3) % 2;
        annotations[`label_${i}`] = {
          type: 'label',
          xValue: kp.time_s,
          yValue: yVal,
          content: keyPointLabelText(kp.name),
          position: { x: col === 0 ? 'end' : 'start', y: row === 0 ? 'start' : row === 1 ? 'center' : 'end' },
          xAdjust: (col === 0 ? -14 : 14),
          yAdjust: row === 0 ? -16 : row === 1 ? 0 : 16,
          backgroundColor: 'rgba(255,255,255,0.95)',
          borderColor: isOrange ? 'rgba(255, 140, 0, 0.5)' : 'rgba(0,0,0,0.15)',
          borderWidth: 1,
          borderRadius: 4,
          color: isOrange ? '#b85800' : '#1a1a1a',
          font: { size: 11 },
          padding: 6
        };
      });

      const bwLine = {
        type: 'line',
        yMin: bodyweight,
        yMax: bodyweight,
        xMin: time[0],
        xMax: time[time.length - 1],
        borderColor: '#999999',
        borderWidth: 1,
        borderDash: [4, 4],
        label: {
          display: true,
          content: 'Bodyweight',
          position: 'end',
          color: '#666666',
          font: { size: 10 }
        }
      };
      annotations.bodyweight = bwLine;

      const startKp = data.key_points.find(k => /Start of movement/i.test(k.name));
      const minForceKp = data.key_points.find(k => /Minimum force/i.test(k.name));
      const takeoffKp = data.key_points.find(k => /Take-off/i.test(k.name));
      const impulseStartKp = minForceKp || startKp;
      if (impulseStartKp && takeoffKp && yMaxForce > 0) {
        annotations.impulse = {
          type: 'box',
          xMin: impulseStartKp.time_s,
          xMax: takeoffKp.time_s,
          yMin: 0,
          yMax: Math.max(60, yMaxForce * 0.05),
          backgroundColor: 'rgba(0,0,0,0.03)',
          borderColor: '#333333',
          borderWidth: 1.5,
          label: {
            display: true,
            content: 'Impulse',
            position: 'center',
            color: '#333333',
            font: { size: 11 }
          }
        };
      }

      const ctx = canvasEl.getContext('2d');
      const datasets = [
        // Fill under curve (draw first so they sit behind the line)
        ...(eccentricFillPoints.length > 0 ? [{
          label: 'Eccentric (area)',
          data: eccentricFillPoints,
          borderColor: 'transparent',
          backgroundColor: 'rgba(255, 140, 0, 0.22)',
          fill: true,
          pointRadius: 0,
          tension: 0.1,
          order: 3
        }] : []),
        ...(concentricFillPoints.length > 0 ? [{
          label: 'Concentric (area)',
          data: concentricFillPoints,
          borderColor: 'transparent',
          backgroundColor: 'rgba(200, 200, 200, 0.45)',
          fill: true,
          pointRadius: 0,
          tension: 0.1,
          order: 3
        }] : []),
        {
          label: 'Total force',
          data: totalPoints,
          borderColor: '#333333',
          backgroundColor: 'transparent',
          borderWidth: 2.5,
          pointRadius: 0,
          tension: 0.1,
          order: 1,
          segment: {
            borderColor: (ctx) => {
              const t = ctx.p1?.parsed?.x;
              if (t == null) return '#333333';
              return getLineColorForPhase(getPhaseAtTime(phases, t));
            }
          }
        },
        {
          label: 'Key points',
          data: keyPointData,
          borderColor: (ctx) => keyPointColors[ctx.dataIndex] === '#FF8C00' ? 'rgba(255,255,255,0.9)' : 'rgba(255,255,255,0.7)',
          backgroundColor: (ctx) => keyPointColors[ctx.dataIndex] || '#333333',
          borderWidth: 2,
          pointRadius: 6,
          pointHoverRadius: 9,
          pointStyle: 'circle',
          order: 0
        },
        { label: 'Left force', data: leftPoints, borderColor: 'rgba(153, 153, 153, 0.6)', backgroundColor: 'transparent', borderWidth: 1, pointRadius: 0, tension: 0.1, borderDash: [4, 2], order: 2 },
        { label: 'Right force', data: rightPoints, borderColor: 'rgba(153, 153, 153, 0.6)', backgroundColor: 'transparent', borderWidth: 1, pointRadius: 0, tension: 0.1, borderDash: [4, 2], order: 2 }
      ];

      const newChart = new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          aspectRatio: 2.5,
          layout: {
            padding: { top: 24, right: 16, bottom: 88, left: 16 }
          },
          plugins: {
            legend: {
              position: 'top',
              labels: {
                color: '#333333',
                font: { size: 11 },
                filter: (item, chart) => {
                  const label = item.text || '';
                  return !/\(area\)|Key points/i.test(label);
                }
              }
            },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  if (ctx.dataset.label === 'Key points' && data.key_points && data.key_points[ctx.dataIndex]) {
                    const kp = data.key_points[ctx.dataIndex];
                    let s = kp.name;
                    if (kp.value_N != null) s += ` · ${Number(kp.value_N).toFixed(1)} N`;
                    if (kp.value_N_per_s != null) s += ` · ${Number(kp.value_N_per_s).toFixed(0)} N/s`;
                    return s;
                  }
                  return null;
                }
              }
            },
            annotation: { clip: false, annotations }
          },
          scales: {
            x: {
              type: 'linear',
              title: { display: true, text: 'Time (s)', color: '#666666', font: { size: 11 } },
              min: time[0],
              max: time[time.length - 1],
              ticks: { maxTicksLimit: 12, color: '#666666', font: { size: 10 } },
              grid: { color: 'rgba(0,0,0,0.08)' }
            },
            y: {
              title: { display: true, text: 'Force (N)', color: '#666666', font: { size: 11 } },
              beginAtZero: true,
              grace: '4%',
              ticks: { color: '#666666', font: { size: 10 } },
              grid: { color: 'rgba(0,0,0,0.08)' }
            }
          }
        },
        plugins: (typeof ChartAnnotation !== 'undefined' ? [ChartAnnotation] : [])
      });

      if (canvasId === 'chart2') chartInstance2 = newChart;
      else chartInstance = newChart;

      if (canvasId !== 'chart2') {
        document.getElementById('chartWrap').style.display = 'block';
        document.getElementById('sections').style.display = 'flex';
        document.getElementById('placeholder').style.display = 'none';
      }
    }

    let primaryData = null;
    let compareData = null;

    function applyPrimaryView(data) {
      try {
        if (!data) return;
        renderMeta(data);
        renderPhaseList(getPhasesForDisplay(data));
        renderKeypointList(getKeyPointsForDisplay(data));
        renderMetricsList(getMetricsForDisplay(data));
        buildChart(data);
        document.getElementById('chartWrap').style.display = 'block';
        document.getElementById('sections').style.display = 'flex';
        document.getElementById('placeholder').style.display = 'none';
        var aid = (typeof window !== 'undefined' && window.ATHLETE_ID) ? window.ATHLETE_ID : '';
        if (aid) document.getElementById('compareToolbar').style.display = 'flex';
      } catch (err) {
        var el = document.getElementById('placeholder');
        if (el) {
          el.textContent = 'Error displaying data: ' + (err && err.message ? err.message : String(err));
          el.style.color = '#c53030';
          el.style.display = 'block';
        }
      }
    }

    function runViewerLoader() {
      try {
        var placeholderEl = document.getElementById('placeholder');
        var dataEl = document.getElementById('viz-data-payload');
        if (dataEl && dataEl.textContent) {
          try {
            var data = JSON.parse(dataEl.textContent);
            primaryData = data;
            if (typeof applyPrimaryView === 'function') {
              applyPrimaryView(data);
            }
          } catch (parseErr) {
            if (placeholderEl) {
              placeholderEl.textContent = 'Invalid data from server.';
              placeholderEl.style.color = '#c53030';
            }
          }
          return;
        }
        if (placeholderEl) {
          placeholderEl.innerHTML = 'This page must be opened from the API using a view link (e.g. /jumptest/<strong>&lt;test_id&gt;</strong>/view). Data is provided by the server only.';
        }
      } catch (e) {
        var placeholderEl = document.getElementById('placeholder');
        if (placeholderEl) {
          placeholderEl.textContent = 'Error: ' + (e && e.message ? e.message : String(e));
          placeholderEl.style.color = '#c53030';
        }
        if (typeof console !== 'undefined' && console.error) console.error('[CMJ viewer]', e);
      }
    }
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', runViewerLoader);
    } else {
      runViewerLoader();
    }

    (function initCompare() {
      var overlay = document.getElementById('compareModalOverlay');
      var listEl = document.getElementById('compareModalList');
      var closeBtn = document.getElementById('compareModalClose');
      var compareBtn = document.getElementById('compareBtn');
      if (!overlay || !listEl || !closeBtn || !compareBtn) return;
      function baseUrl() {
        var p = window.location.pathname;
        var m = p.match(/^\/jumptest\/[^/]+\/view\/?$/);
        return m ? p.replace(/\/[^/]+\/view\/?$/, '') : (p.replace(/\/view\/?$/, '') || '/jumptest');
      }
      function showModal() { overlay.classList.add('visible'); overlay.setAttribute('aria-hidden', 'false'); }
      function hideModal() { overlay.classList.remove('visible'); overlay.setAttribute('aria-hidden', 'true'); }
      closeBtn.addEventListener('click', hideModal);
      overlay.addEventListener('click', function(e) { if (e.target === overlay) hideModal(); });
      compareBtn.addEventListener('click', function() {
        var athleteId = (typeof window !== 'undefined' && window.ATHLETE_ID) ? window.ATHLETE_ID : '';
        var currentId = (typeof window !== 'undefined' && window.CURRENT_JUMP_TEST_ID) ? window.CURRENT_JUMP_TEST_ID : '';
        if (!athleteId) return;
        listEl.innerHTML = '<li class="empty">Loading…</li>';
        showModal();
        var base = baseUrl();
        fetch(base + '/by-athlete/' + encodeURIComponent(athleteId))
          .then(function(r) { if (!r.ok) throw new Error(r.status); return r.json(); })
          .then(function(tests) {
            if (!Array.isArray(tests)) tests = [];
            var other = tests.filter(function(t) { return t.id && t.id !== currentId; });
            listEl.innerHTML = '';
            if (other.length === 0) {
              listEl.innerHTML = '<li class="empty">No other tests to compare.</li>';
              return;
            }
            other.forEach(function(t) {
              var li = document.createElement('li');
              var typeStr = escapeHtml(t.test_type || 'CMJ');
              var idStr = t.id ? escapeHtml(t.id.substring(0, 8)) + '\u2026' : '';
              var durStr = t.test_duration != null ? escapeHtml(Number(t.test_duration).toFixed(2) + ' s') : '';
              li.innerHTML = '<span>' + typeStr + ' \u00b7 ' + idStr + '</span><span class="duration">' + durStr + '</span>';
              li.dataset.id = t.id;
              li.addEventListener('click', function() {
                var id = this.dataset.id;
                if (!id) return;
                listEl.innerHTML = '<li class="empty">Loading…</li>';
                fetch(base + '/' + encodeURIComponent(id) + '/viz')
                  .then(function(r) { if (!r.ok) throw new Error(r.status); return r.json(); })
                  .then(function(viz) {
                    compareData = viz;
                    renderComparison(primaryData, compareData);
                    hideModal();
                  })
                  .catch(function() { listEl.innerHTML = '<li class="empty">Failed to load test.</li>'; });
              });
              listEl.appendChild(li);
            });
          })
          .catch(function() { listEl.innerHTML = '<li class="empty">Failed to load list.</li>'; });
      });
    })();
  </script>
</body>
</html>
